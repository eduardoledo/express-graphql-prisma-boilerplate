# express-graphql-prisma-boilerplate
A boilerplate project for creating a [GraphQL](https://graphql.org/) API using [nodejs](https://nodejs.org/) with [typescript](https://www.typescriptlang.org/) [express](https://expressjs.com/) and [prisma](https://www.prisma.io/)

# Getting started
First things first: clone the repo and downloads all dependencies:  
```bash
$ git clone https://github.com/eduardoledo/express-graphql-prisma-boilerplate  
$ npm install
```

You need to create a `.env` file or set the following environment variables:
```bash
DATABASE_URL="sqlite:./database.sqlite"
PORT=3000
ACCESS_TOKEN_SECRET="<your-access-token-secret>"
REFRESH_TOKEN_SECRET="<refresh-tocken-secret>"
```

You can now run the server with 
```bash
$ npm run startDev
```

# Project structure

The project is structured as following: 

```
  src
    |-- graphql
    |   |-- authenticated
    |   |   |-- mutation.graphql
    |   |-- directives
    |   |   |-- directive.filter.ts
    |   |   |-- hasPermission.ts
    |   |   |-- hasRole.ts
    |   |   |-- isAuthenticated.ts
    |   |
    |   |-- public
    |   |   |-- auth
    |   |       |-- auth.query.graphql
    |   |       |-- auth.query.service.ts
    |   |       |-- auth.resolver.ts
    |   |       |-- loginresult.graphql
    |   |
    |   |-- reaolver.generator.ts
    |   |-- schema.generator.ts
    |   |-- type.generator.ts
    |
    |-- helpers
    |   |-- compose.ts
    |   |-- messages.ts
    |
    |-- middlewares
    |   |-- auth
    |   |   |-- auth-middleware.ts
    |   |
    |   |-- graphql-express
    |   |   |-- graphql-express-middleware.ts
    |   
    |-- prisma
        |-- client (autogenerated)
        |-- models
        |   |-- permission.prisma
        |   |-- refresh_token.prisma
        |   |-- role.prisma
        |   |-- user.prisma
        |
        |-- base.prisma
        |-- schema.prisma
        |-- index.ts
    
  package.json
  README.md
  tsconfig.json
```

# Authentication

We use JWT to maintain a user's identity across requests. The default TTL for the JWT is 10 minutes.
For this we provide four query methods in the API:

```graphql
type Query {
    login(email: String!, password: String!): LoginResult!
    logout(token: String!): Boolean!
    register(email: String!, password: String!): LoginResult!
    refreshToken(token: String!): String!
}

type LoginResult {
    accessToken: String!
    refreshToken: String!
}

```

## Login / register:

```graphql
query login($email:String!, $password:String!) {
    login(email: $email, password: $password) {
        accessToken
        refreshToken
    }
}
# query variables:
{
	"email": "eduardo.ledo@gmail.com",
	"password": "test"
}
```

A successful login looks like this:

```json
{
  "data": {
    "login": {
      "accessToken": "<access-token>",
      "refreshToken": "<refresh-token>"
    }
  }
}
```

 And an unsuccessful login would look like this:

```json
{
  "errors": [
    "Invalid email or password!"
  ],
  "data": null
}
```

## Refresh token

For refreshig the accessToken you have to call `refreshToken` whith the refresh token you got on login/register:

```graphql
query login($email:String!, $password:String!) {
    login(email: $email, password: $password) {
        accessToken
        refreshToken
    }
}
# query variables:
{
	"refreshTokent": "<refresh-token>"
}
```

Succesful refresh looks like this:

```json
{
  "data": {
    "refreshToken": "<new-access-token>"
  }
}
```

An unsuccessful refresh looks like this:

```json
{
  "errors": [
    "Invalid token!"
  ],
  "data": null
}
```

## Logout

If you need to invalidate a refreshToken (ie: you think it might have been compromised) we provide a logout query:

```graphql
query logout($token: String!) {
  logout(token: $token)
}
```

A successful logout looks like this:

```json
{
  "data": {
    "logout": true
  }
}
```

An unsuccessful logout looks like this:

```json
{
  "errors": [
    "Invalid token!"
  ],
  "data": null
}
```


# Database

We use prisma.io ORM so the project can be DB agnostic.  
It takes the connection url from the `DATABASE_URL` environment variable.
The DB schema is located in `src/prisma/models`. You can define each model in its own file
and then call `npm run compileDBModels`. This merges all model files with `base.prisma` and then generates
the new client folder.

See [prisma docs on data models](https://www.prisma.io/docs/concepts/components/prisma-schema/data-model) for details.

# Authorization / Authentication

There are two options for requiring authorization in the API:

* [Folder structure (authentication only)](#folder-structure)
* [Schema directives (authentication and/or authorization)](#schema-directives)

Either option "hides" everithing in the schema thats marked as "user needs to be authenticated to see this"

## Folder structure

With this option you can simpli create your schema files inside `src/graphql/public` or `src/graphql/authenticated` and thats it. Everything inside `src/graphql/public` is visible to everyone and everything inside `src/graphql/authenticated` is only visible to authenticated users.
This is useful when you don't need to check for authorization (ie: roles and/or permissions)

## Schema directives

Schema directives are a little more flexible. You annotate the Schema object or field with the corresponding directive:

```graphql
Query {
  oldField: String! @deprecated(reason: "Use newField instead")
  newField: String!
}
```

There are three schema directives defined for this purpose:

* [@isAuthenticated](#isauthenticated)
* [@hasRole](#hasrole)
* [@hasPermission](#haspermission)

### @isAuthenticated

This has the same effect as using [Folder sctructure base authentication](#folder-structure) and hides the object/field fron unauthenticated users:

```graphql
Query {
  publicField: String!
  someOtherField: String! @isAuthenticated
}
```

In this example, public field is visible to everyone and someOtherField can only be seen by authenticated users (even when asking the server for the schema definition).

### @hasRole

This directive takes as parameter (`requires`) the name of the role as defined in the `roles` database table. A user can have multiple roles.

```graphql
Query {
  user: User @hasRole(requires: ROLE_USER)
  allUsers: [User!] @hasRole(requires: ROLE_SUPER_ADMIN)
}
```

### @hasPermission

This directive takes as parameter (`requires`) the name of the role as defined in the `roles` database table. A user can have multiple roles.

```graphql
Mutation {
  deleteUser(id: Int!): Boolean @hasPermission(requires: PERMISSION_DELETE_USER)
}
```
